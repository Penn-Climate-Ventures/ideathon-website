{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { BaseLoader, PageResourceStatus } from \"./loader\";\nimport { findPath } from \"./find-path\";\nimport getSocket from \"./socketIo\";\nimport normalizePagePath from \"./normalize-page-path\";\nimport isEqual from \"lodash/isEqual\";\n\nfunction mergePageEntry(cachedPage, newPageData) {\n  return _objectSpread(_objectSpread({}, cachedPage), {}, {\n    payload: _objectSpread(_objectSpread({}, cachedPage.payload), {}, {\n      json: newPageData.result,\n      page: _objectSpread(_objectSpread({}, cachedPage.payload.page), {}, {\n        staticQueryResults: newPageData.staticQueryResults\n      })\n    })\n  });\n}\n\nvar DevLoader = function (_BaseLoader) {\n  _inherits(DevLoader, _BaseLoader);\n\n  var _super = _createSuper(DevLoader);\n\n  function DevLoader(syncRequires, matchPaths) {\n    var _this;\n\n    _classCallCheck(this, DevLoader);\n\n    var loadComponent = function loadComponent(chunkName) {\n      return Promise.resolve(syncRequires.components[chunkName]);\n    };\n\n    _this = _super.call(this, loadComponent, matchPaths);\n    var socket = getSocket();\n    _this.notFoundPagePathsInCaches = new Set();\n\n    if (socket) {\n      socket.on(\"message\", function (msg) {\n        if (msg.type === \"staticQueryResult\") {\n          _this.handleStaticQueryResultHotUpdate(msg);\n        } else if (msg.type === \"pageQueryResult\") {\n          _this.handlePageQueryResultHotUpdate(msg);\n        } else if (msg.type === \"stalePageData\") {\n          _this.handleStalePageDataMessage(msg);\n        }\n      });\n    } else if (process.env.NODE_ENV !== \"test\") {\n      console.warn(\"Could not get web socket\");\n    }\n\n    return _this;\n  }\n\n  _createClass(DevLoader, [{\n    key: \"loadPage\",\n    value: function loadPage(pagePath) {\n      var _this2 = this;\n\n      var realPath = findPath(pagePath);\n      return _get(_getPrototypeOf(DevLoader.prototype), \"loadPage\", this).call(this, realPath).then(function (result) {\n        if (_this2.isPageNotFound(realPath)) {\n          _this2.notFoundPagePathsInCaches.add(realPath);\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"loadPageDataJson\",\n    value: function loadPageDataJson(rawPath) {\n      var _this3 = this;\n\n      return _get(_getPrototypeOf(DevLoader.prototype), \"loadPageDataJson\", this).call(this, rawPath).then(function (data) {\n        if (data.status === PageResourceStatus.Error && rawPath !== \"/dev-404-page/\") {\n          console.error(\"404 page could not be found. Checkout https://www.gatsbyjs.org/docs/how-to/adding-common-features/add-404-page/\");\n          return _this3.loadPageDataJson(\"/dev-404-page/\").then(function (result) {\n            return _extends({}, data, result);\n          });\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"doPrefetch\",\n    value: function doPrefetch(pagePath) {\n      if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n        return Promise.resolve();\n      }\n\n      return _get(_getPrototypeOf(DevLoader.prototype), \"doPrefetch\", this).call(this, pagePath).then(function (result) {\n        return result.payload;\n      });\n    }\n  }, {\n    key: \"handleStaticQueryResultHotUpdate\",\n    value: function handleStaticQueryResultHotUpdate(msg) {\n      var newResult = msg.payload.result;\n      var cacheKey = msg.payload.id;\n      var cachedResult = this.staticQueryDb[cacheKey];\n\n      if (!isEqual(newResult, cachedResult)) {\n        this.staticQueryDb[cacheKey] = newResult;\n\n        ___emitter.emit(\"staticQueryResult\", newResult);\n      }\n    }\n  }, {\n    key: \"handlePageQueryResultHotUpdate\",\n    value: function handlePageQueryResultHotUpdate(msg) {\n      var _this$pageDataDb$get,\n          _this4 = this;\n\n      var newPageData = msg.payload.result;\n      var pageDataDbCacheKey = normalizePagePath(msg.payload.id);\n      var cachedPageData = (_this$pageDataDb$get = this.pageDataDb.get(pageDataDbCacheKey)) == null ? void 0 : _this$pageDataDb$get.payload;\n\n      if (!isEqual(newPageData, cachedPageData)) {\n        this.pageDataDb.set(pageDataDbCacheKey, {\n          pagePath: pageDataDbCacheKey,\n          payload: newPageData,\n          status: \"success\"\n        });\n        var cachedPage = this.pageDb.get(pageDataDbCacheKey);\n\n        if (cachedPage) {\n          this.pageDb.set(pageDataDbCacheKey, mergePageEntry(cachedPage, newPageData));\n        }\n\n        if (pageDataDbCacheKey === \"/404.html\") {\n          this.notFoundPagePathsInCaches.forEach(function (notFoundPath) {\n            var previousPageDataEntry = _this4.pageDataDb.get(notFoundPath);\n\n            if (previousPageDataEntry) {\n              _this4.pageDataDb.set(notFoundPath, _objectSpread(_objectSpread({}, previousPageDataEntry), {}, {\n                payload: newPageData\n              }));\n            }\n\n            var previousPageEntry = _this4.pageDb.get(notFoundPath);\n\n            if (previousPageEntry) {\n              _this4.pageDb.set(notFoundPath, mergePageEntry(previousPageEntry, newPageData));\n            }\n          });\n        }\n\n        ___emitter.emit(\"pageQueryResult\", newPageData);\n      }\n    }\n  }, {\n    key: \"handleStalePageDataMessage\",\n    value: function handleStalePageDataMessage(msg) {\n      var _this5 = this;\n\n      msg.payload.stalePageDataPaths.forEach(function (dirtyQueryId) {\n        if (dirtyQueryId === \"/dev-404-page/\" || dirtyQueryId === \"/404.html\") {\n          return;\n        }\n\n        var normalizedId = normalizePagePath(dirtyQueryId);\n\n        var cachedPageData = _this5.pageDataDb.get(normalizedId);\n\n        if (cachedPageData) {\n          _this5.pageDataDb.set(normalizedId, _objectSpread(_objectSpread({}, cachedPageData), {}, {\n            stale: true\n          }));\n        }\n\n        var cachedPage = _this5.pageDb.get(normalizedId);\n\n        if (cachedPage) {\n          _this5.pageDb.set(normalizedId, _objectSpread(_objectSpread({}, cachedPage), {}, {\n            payload: _objectSpread(_objectSpread({}, cachedPage.payload), {}, {\n              stale: true\n            })\n          }));\n        }\n      });\n    }\n  }]);\n\n  return DevLoader;\n}(BaseLoader);\n\nexport default DevLoader;","map":{"version":3,"sources":["/Users/aliristang/Desktop/prize-website/.cache/dev-loader.js"],"names":["BaseLoader","PageResourceStatus","findPath","getSocket","normalizePagePath","isEqual","mergePageEntry","cachedPage","newPageData","payload","json","result","page","staticQueryResults","DevLoader","syncRequires","matchPaths","loadComponent","chunkName","Promise","resolve","components","socket","notFoundPagePathsInCaches","Set","on","msg","type","handleStaticQueryResultHotUpdate","handlePageQueryResultHotUpdate","handleStalePageDataMessage","process","env","NODE_ENV","console","warn","pagePath","realPath","then","isPageNotFound","add","rawPath","data","status","Error","error","loadPageDataJson","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","newResult","cacheKey","id","cachedResult","staticQueryDb","___emitter","emit","pageDataDbCacheKey","cachedPageData","pageDataDb","get","set","pageDb","forEach","notFoundPath","previousPageDataEntry","previousPageEntry","stalePageDataPaths","dirtyQueryId","normalizedId","stale"],"mappings":"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","sourcesContent":["import { BaseLoader, PageResourceStatus } from \"./loader\"\nimport { findPath } from \"./find-path\"\n\nimport getSocket from \"./socketIo\"\nimport normalizePagePath from \"./normalize-page-path\"\n\n// TODO move away from lodash\nimport isEqual from \"lodash/isEqual\"\n\nfunction mergePageEntry(cachedPage, newPageData) {\n  return {\n    ...cachedPage,\n    payload: {\n      ...cachedPage.payload,\n      json: newPageData.result,\n      page: {\n        ...cachedPage.payload.page,\n        staticQueryResults: newPageData.staticQueryResults,\n      },\n    },\n  }\n}\n\nclass DevLoader extends BaseLoader {\n  constructor(syncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      Promise.resolve(syncRequires.components[chunkName])\n\n    super(loadComponent, matchPaths)\n\n    const socket = getSocket()\n\n    this.notFoundPagePathsInCaches = new Set()\n\n    if (socket) {\n      socket.on(`message`, msg => {\n        if (msg.type === `staticQueryResult`) {\n          this.handleStaticQueryResultHotUpdate(msg)\n        } else if (msg.type === `pageQueryResult`) {\n          this.handlePageQueryResultHotUpdate(msg)\n        } else if (msg.type === `stalePageData`) {\n          this.handleStalePageDataMessage(msg)\n        }\n      })\n    } else if (process.env.NODE_ENV !== `test`) {\n      console.warn(`Could not get web socket`)\n    }\n  }\n\n  loadPage(pagePath) {\n    const realPath = findPath(pagePath)\n    return super.loadPage(realPath).then(result => {\n      if (this.isPageNotFound(realPath)) {\n        this.notFoundPagePathsInCaches.add(realPath)\n      }\n\n      return result\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      // when we can't find a proper 404.html we fallback to dev-404-page\n      // we need to make sure to mark it as not found.\n      if (\n        data.status === PageResourceStatus.Error &&\n        rawPath !== `/dev-404-page/`\n      ) {\n        console.error(\n          `404 page could not be found. Checkout https://www.gatsbyjs.org/docs/how-to/adding-common-features/add-404-page/`\n        )\n        return this.loadPageDataJson(`/dev-404-page/`).then(result =>\n          Object.assign({}, data, result)\n        )\n      }\n\n      return data\n    })\n  }\n\n  doPrefetch(pagePath) {\n    if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n      return Promise.resolve()\n    }\n    return super.doPrefetch(pagePath).then(result => result.payload)\n  }\n\n  handleStaticQueryResultHotUpdate(msg) {\n    const newResult = msg.payload.result\n\n    const cacheKey = msg.payload.id\n    const cachedResult = this.staticQueryDb[cacheKey]\n    if (!isEqual(newResult, cachedResult)) {\n      this.staticQueryDb[cacheKey] = newResult\n      ___emitter.emit(`staticQueryResult`, newResult)\n    }\n  }\n\n  handlePageQueryResultHotUpdate(msg) {\n    const newPageData = msg.payload.result\n\n    const pageDataDbCacheKey = normalizePagePath(msg.payload.id)\n    const cachedPageData = this.pageDataDb.get(pageDataDbCacheKey)?.payload\n\n    if (!isEqual(newPageData, cachedPageData)) {\n      // TODO: if this is update for current page and there are any new static queries added\n      // that are not yet cached, there is currently no trigger to fetch them (yikes)\n      // always update canonical key for pageDataDb\n      this.pageDataDb.set(pageDataDbCacheKey, {\n        pagePath: pageDataDbCacheKey,\n        payload: newPageData,\n        status: `success`,\n      })\n\n      const cachedPage = this.pageDb.get(pageDataDbCacheKey)\n      if (cachedPage) {\n        this.pageDb.set(\n          pageDataDbCacheKey,\n          mergePageEntry(cachedPage, newPageData)\n        )\n      }\n\n      // Additionally if those are query results for \"/404.html\"\n      // we have to update all paths user wanted to visit, but didn't have\n      // page for it, because we do store them under (normalized) path\n      // user wanted to visit\n      if (pageDataDbCacheKey === `/404.html`) {\n        this.notFoundPagePathsInCaches.forEach(notFoundPath => {\n          const previousPageDataEntry = this.pageDataDb.get(notFoundPath)\n          if (previousPageDataEntry) {\n            this.pageDataDb.set(notFoundPath, {\n              ...previousPageDataEntry,\n              payload: newPageData,\n            })\n          }\n\n          const previousPageEntry = this.pageDb.get(notFoundPath)\n          if (previousPageEntry) {\n            this.pageDb.set(\n              notFoundPath,\n              mergePageEntry(previousPageEntry, newPageData)\n            )\n          }\n        })\n      }\n\n      ___emitter.emit(`pageQueryResult`, newPageData)\n    }\n  }\n\n  handleStalePageDataMessage(msg) {\n    msg.payload.stalePageDataPaths.forEach(dirtyQueryId => {\n      if (dirtyQueryId === `/dev-404-page/` || dirtyQueryId === `/404.html`) {\n        // those pages are not on demand so skipping\n        return\n      }\n\n      const normalizedId = normalizePagePath(dirtyQueryId)\n\n      // We can't just delete items in caches, because then\n      // using history.back() would show dev-404 page\n      // due to our special handling of it in root.js (loader.isPageNotFound check)\n      // so instead we mark it as stale and instruct loader's async methods\n      // to refetch resources if they are marked as stale\n\n      const cachedPageData = this.pageDataDb.get(normalizedId)\n      if (cachedPageData) {\n        // if we have page data in cache, mark it as stale\n        this.pageDataDb.set(normalizedId, {\n          ...cachedPageData,\n          stale: true,\n        })\n      }\n\n      const cachedPage = this.pageDb.get(normalizedId)\n      if (cachedPage) {\n        // if we have page data in cache, mark it as stale\n        this.pageDb.set(normalizedId, {\n          ...cachedPage,\n          payload: { ...cachedPage.payload, stale: true },\n        })\n      }\n    })\n  }\n}\n\nexport default DevLoader\n"]},"metadata":{},"sourceType":"module"}