{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/aliristang/Desktop/prize-website/.cache/navigation.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport loader, { PageResourceStatus } from \"./loader\";\nimport redirects from \"./redirects.json\";\nimport { apiRunner } from \"./api-runner-browser\";\nimport emitter from \"./emitter\";\nimport { RouteAnnouncerProps } from \"./route-announcer-props\";\nimport { navigate as reachNavigate } from \"@reach/router\";\nimport { globalHistory } from \"@reach/router/lib/history\";\nimport { parsePath } from \"gatsby-link\";\nvar redirectMap = new Map();\nvar redirectIgnoreCaseMap = new Map();\nredirects.forEach(function (redirect) {\n  if (redirect.ignoreCase) {\n    redirectIgnoreCaseMap.set(redirect.fromPath, redirect);\n  } else {\n    redirectMap.set(redirect.fromPath, redirect);\n  }\n});\n\nfunction maybeRedirect(pathname) {\n  var redirect = redirectMap.get(pathname);\n\n  if (!redirect) {\n    redirect = redirectIgnoreCaseMap.get(pathname.toLowerCase());\n  }\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!loader.isPageNotFound(pathname)) {\n        console.error(\"The route \\\"\" + pathname + \"\\\" matches both a page and a redirect; this is probably not intentional.\");\n      }\n    }\n\n    window.___replace(redirect.toPath);\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvar onPreRouteUpdate = function onPreRouteUpdate(location, prevLocation) {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(\"onPreRouteUpdate\", {\n      location: location,\n      prevLocation: prevLocation\n    });\n  }\n};\n\nvar onRouteUpdate = function onRouteUpdate(location, prevLocation) {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(\"onRouteUpdate\", {\n      location: location,\n      prevLocation: prevLocation\n    });\n\n    if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND && process.env.GATSBY_QUERY_ON_DEMAND_LOADING_INDICATOR === \"true\") {\n      emitter.emit(\"onRouteUpdate\", {\n        location: location,\n        prevLocation: prevLocation\n      });\n    }\n  }\n};\n\nvar navigate = function navigate(to) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof to === \"number\") {\n    globalHistory.navigate(to);\n    return;\n  }\n\n  var _parsePath = parsePath(to),\n      pathname = _parsePath.pathname;\n\n  var redirect = redirectMap.get(pathname);\n\n  if (!redirect) {\n    redirect = redirectIgnoreCaseMap.get(pathname.toLowerCase());\n  }\n\n  if (redirect) {\n    to = redirect.toPath;\n    pathname = parsePath(to).pathname;\n  }\n\n  if (window.___swUpdated) {\n    window.location = pathname;\n    return;\n  }\n\n  var timeoutId = setTimeout(function () {\n    emitter.emit(\"onDelayedLoadPageResources\", {\n      pathname: pathname\n    });\n    apiRunner(\"onRouteUpdateDelayed\", {\n      location: window.location\n    });\n  }, 1000);\n  loader.loadPage(pathname).then(function (pageResources) {\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, \"\", location.href);\n      window.location = pathname;\n      clearTimeout(timeoutId);\n      return;\n    }\n\n    if (process.env.NODE_ENV === \"production\" && pageResources) {\n      if (pageResources.page.webpackCompilationHash !== window.___webpackCompilationHash) {\n        if (\"serviceWorker\" in navigator && navigator.serviceWorker.controller !== null && navigator.serviceWorker.controller.state === \"activated\") {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: \"clearPathResources\"\n          });\n        }\n\n        window.location = pathname;\n      }\n    }\n\n    reachNavigate(to, options);\n    clearTimeout(timeoutId);\n  });\n};\n\nfunction shouldUpdateScroll(prevRouterProps, _ref) {\n  var _this = this;\n\n  var location = _ref.location;\n  var pathname = location.pathname,\n      hash = location.hash;\n  var results = apiRunner(\"shouldUpdateScroll\", {\n    prevRouterProps: prevRouterProps,\n    pathname: pathname,\n    routerProps: {\n      location: location\n    },\n    getSavedScrollPosition: function getSavedScrollPosition(args) {\n      return [0, _this._stateStorage.read(args, args.key)];\n    }\n  });\n\n  if (results.length > 0) {\n    return results[results.length - 1];\n  }\n\n  if (prevRouterProps) {\n    var oldPathname = prevRouterProps.location.pathname;\n\n    if (oldPathname === pathname) {\n      return hash ? decodeURI(hash.slice(1)) : [0, 0];\n    }\n  }\n\n  return true;\n}\n\nfunction init() {\n  globalHistory.listen(function (args) {\n    args.location.action = args.action;\n  });\n\n  window.___push = function (to) {\n    return navigate(to, {\n      replace: false\n    });\n  };\n\n  window.___replace = function (to) {\n    return navigate(to, {\n      replace: true\n    });\n  };\n\n  window.___navigate = function (to, options) {\n    return navigate(to, options);\n  };\n\n  maybeRedirect(window.location.pathname);\n}\n\nvar RouteAnnouncer = function (_React$Component) {\n  _inherits(RouteAnnouncer, _React$Component);\n\n  var _super = _createSuper(RouteAnnouncer);\n\n  function RouteAnnouncer(props) {\n    var _this2;\n\n    _classCallCheck(this, RouteAnnouncer);\n\n    _this2 = _super.call(this, props);\n    _this2.announcementRef = React.createRef();\n    return _this2;\n  }\n\n  _createClass(RouteAnnouncer, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, nextProps) {\n      var _this3 = this;\n\n      requestAnimationFrame(function () {\n        var pageName = \"new page at \" + _this3.props.location.pathname;\n\n        if (document.title) {\n          pageName = document.title;\n        }\n\n        var pageHeadings = document.querySelectorAll(\"#gatsby-focus-wrapper h1\");\n\n        if (pageHeadings && pageHeadings.length) {\n          pageName = pageHeadings[0].textContent;\n        }\n\n        var newAnnouncement = \"Navigated to \" + pageName;\n\n        if (_this3.announcementRef.current) {\n          var oldAnnouncement = _this3.announcementRef.current.innerText;\n\n          if (oldAnnouncement !== newAnnouncement) {\n            _this3.announcementRef.current.innerText = newAnnouncement;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", _extends({}, RouteAnnouncerProps, {\n        ref: this.announcementRef,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 216,\n          columnNumber: 12\n        }\n      }));\n    }\n  }]);\n\n  return RouteAnnouncer;\n}(React.Component);\n\nvar compareLocationProps = function compareLocationProps(prevLocation, nextLocation) {\n  var _prevLocation$state, _nextLocation$state;\n\n  if (prevLocation.href !== nextLocation.href) {\n    return true;\n  }\n\n  if ((prevLocation == null ? void 0 : (_prevLocation$state = prevLocation.state) == null ? void 0 : _prevLocation$state.key) !== (nextLocation == null ? void 0 : (_nextLocation$state = nextLocation.state) == null ? void 0 : _nextLocation$state.key)) {\n    return true;\n  }\n\n  return false;\n};\n\nvar RouteUpdates = function (_React$Component2) {\n  _inherits(RouteUpdates, _React$Component2);\n\n  var _super2 = _createSuper(RouteUpdates);\n\n  function RouteUpdates(props) {\n    var _this4;\n\n    _classCallCheck(this, RouteUpdates);\n\n    _this4 = _super2.call(this, props);\n    onPreRouteUpdate(props.location, null);\n    return _this4;\n  }\n\n  _createClass(RouteUpdates, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      onRouteUpdate(this.props.location, null);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(prevProps) {\n      if (compareLocationProps(prevProps.location, this.props.location)) {\n        onPreRouteUpdate(this.props.location, prevProps.location);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (compareLocationProps(prevProps.location, this.props.location)) {\n        onRouteUpdate(this.props.location, prevProps.location);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(React.Fragment, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 259,\n          columnNumber: 7\n        }\n      }, this.props.children, React.createElement(RouteAnnouncer, {\n        location: location,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 261,\n          columnNumber: 9\n        }\n      }));\n    }\n  }]);\n\n  return RouteUpdates;\n}(React.Component);\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired\n};\nexport { init, shouldUpdateScroll, RouteUpdates };","map":{"version":3,"sources":["/Users/aliristang/Desktop/prize-website/.cache/navigation.js"],"names":["React","PropTypes","loader","PageResourceStatus","redirects","apiRunner","emitter","RouteAnnouncerProps","navigate","reachNavigate","globalHistory","parsePath","redirectMap","Map","redirectIgnoreCaseMap","forEach","redirect","ignoreCase","set","fromPath","maybeRedirect","pathname","get","toLowerCase","process","env","NODE_ENV","isPageNotFound","console","error","window","___replace","toPath","onPreRouteUpdate","location","prevLocation","onRouteUpdate","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","GATSBY_QUERY_ON_DEMAND_LOADING_INDICATOR","emit","to","options","___swUpdated","timeoutId","setTimeout","loadPage","then","pageResources","status","Error","history","replaceState","href","clearTimeout","page","webpackCompilationHash","___webpackCompilationHash","navigator","serviceWorker","controller","state","postMessage","gatsbyApi","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","key","length","oldPathname","decodeURI","slice","init","listen","action","___push","replace","___navigate","RouteAnnouncer","props","announcementRef","createRef","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","querySelectorAll","textContent","newAnnouncement","current","oldAnnouncement","innerText","Component","compareLocationProps","nextLocation","RouteUpdates","children","propTypes","object","isRequired"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader, { PageResourceStatus } from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { RouteAnnouncerProps } from \"./route-announcer-props\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { globalHistory } from \"@reach/router/lib/history\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\n\nconst redirectMap = new Map()\nconst redirectIgnoreCaseMap = new Map()\n\nredirects.forEach(redirect => {\n  if (redirect.ignoreCase) {\n    redirectIgnoreCaseMap.set(redirect.fromPath, redirect)\n  } else {\n    redirectMap.set(redirect.fromPath, redirect)\n  }\n})\n\nfunction maybeRedirect(pathname) {\n  let redirect = redirectMap.get(pathname)\n  if (!redirect) {\n    redirect = redirectIgnoreCaseMap.get(pathname.toLowerCase())\n  }\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      if (!loader.isPageNotFound(pathname)) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n    if (\n      process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND &&\n      process.env.GATSBY_QUERY_ON_DEMAND_LOADING_INDICATOR === `true`\n    ) {\n      emitter.emit(`onRouteUpdate`, { location, prevLocation })\n    }\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  // Support forward/backward navigation with numbers\n  // navigate(-2) (jumps back 2 history steps)\n  // navigate(2)  (jumps forward 2 history steps)\n  if (typeof to === `number`) {\n    globalHistory.navigate(to)\n    return\n  }\n\n  let { pathname } = parsePath(to)\n  let redirect = redirectMap.get(pathname)\n  if (!redirect) {\n    redirect = redirectIgnoreCaseMap.get(pathname.toLowerCase())\n  }\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === PageResourceStatus.Error) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n      clearTimeout(timeoutId)\n      return\n    }\n\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => [\n      0,\n      this._stateStorage.read(args, args.key),\n    ],\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // The \"scroll-behavior\" package expects the \"action\" to be on the location\n  // object so let's copy it over.\n  globalHistory.listen(args => {\n    args.location.action = args.action\n  })\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document.querySelectorAll(`#gatsby-focus-wrapper h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      if (this.announcementRef.current) {\n        const oldAnnouncement = this.announcementRef.current.innerText\n        if (oldAnnouncement !== newAnnouncement) {\n          this.announcementRef.current.innerText = newAnnouncement\n        }\n      }\n    })\n  }\n\n  render() {\n    return <div {...RouteAnnouncerProps} ref={this.announcementRef}></div>\n  }\n}\n\nconst compareLocationProps = (prevLocation, nextLocation) => {\n  if (prevLocation.href !== nextLocation.href) {\n    return true\n  }\n\n  if (prevLocation?.state?.key !== nextLocation?.state?.key) {\n    return true\n  }\n\n  return false\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  shouldComponentUpdate(prevProps) {\n    if (compareLocationProps(prevProps.location, this.props.location)) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n    return false\n  }\n\n  componentDidUpdate(prevProps) {\n    if (compareLocationProps(prevProps.location, this.props.location)) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n"]},"metadata":{},"sourceType":"module"}