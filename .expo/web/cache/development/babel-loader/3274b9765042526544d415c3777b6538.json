{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/aliristang/Desktop/prize-website/.cache/query-result-store.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from \"react\";\nimport { StaticQueryContext } from \"gatsby\";\nimport { registerPath as socketRegisterPath, unregisterPath as socketUnregisterPath } from \"./socketIo\";\nimport PageRenderer from \"./page-renderer\";\nimport normalizePagePath from \"./normalize-page-path\";\nimport loader, { getStaticQueryResults } from \"./loader\";\n\nif (process.env.NODE_ENV === \"production\") {\n  throw new Error(\"It appears like Gatsby is misconfigured. JSONStore is Gatsby internal \" + \"development-only component and should never be used in production.\\n\\n\" + \"Unless your site has a complex or custom webpack/Gatsby \" + \"configuration this is likely a bug in Gatsby. \" + \"Please report this at https://github.com/gatsbyjs/gatsby/issues \" + \"with steps to reproduce this error.\");\n}\n\nvar getPathFromProps = function getPathFromProps(props) {\n  return props.pageResources && props.pageResources.page ? normalizePagePath(props.pageResources.page.path) : undefined;\n};\n\nexport var PageQueryStore = function (_React$Component) {\n  _inherits(PageQueryStore, _React$Component);\n\n  var _super = _createSuper(PageQueryStore);\n\n  function PageQueryStore(props) {\n    var _this;\n\n    _classCallCheck(this, PageQueryStore);\n\n    _this = _super.call(this, props);\n\n    _this.handleMittEvent = function () {\n      _this.setState(function (state) {\n        return {\n          page: state.path ? loader.loadPageSync(normalizePagePath(state.path)) : null\n        };\n      });\n    };\n\n    _this.state = {\n      pageData: null,\n      path: null\n    };\n    return _this;\n  }\n\n  _createClass(PageQueryStore, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      socketRegisterPath(getPathFromProps(this.props));\n\n      ___emitter.on(\"pageQueryResult\", this.handleMittEvent);\n\n      ___emitter.on(\"onPostLoadPageResources\", this.handleMittEvent);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      socketUnregisterPath(this.state.path);\n\n      ___emitter.off(\"pageQueryResult\", this.handleMittEvent);\n\n      ___emitter.off(\"onPostLoadPageResources\", this.handleMittEvent);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      return this.props.location !== nextProps.location || this.state.path !== nextState.path || this.state.page !== nextState.page;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.state.page) {\n        return React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 87,\n            columnNumber: 14\n          }\n        });\n      }\n\n      return React.createElement(PageRenderer, _extends({}, this.props, this.state.page.json, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 90,\n          columnNumber: 12\n        }\n      }));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      var newPath = getPathFromProps(props);\n\n      if (newPath !== state.path) {\n        socketUnregisterPath(state.path);\n        socketRegisterPath(newPath);\n        return {\n          path: newPath,\n          page: newPath ? loader.loadPageSync(normalizePagePath(newPath)) : null\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return PageQueryStore;\n}(React.Component);\nexport var StaticQueryStore = function (_React$Component2) {\n  _inherits(StaticQueryStore, _React$Component2);\n\n  var _super2 = _createSuper(StaticQueryStore);\n\n  function StaticQueryStore(props) {\n    var _this2;\n\n    _classCallCheck(this, StaticQueryStore);\n\n    _this2 = _super2.call(this, props);\n\n    _this2.handleMittEvent = function () {\n      _this2.setState({\n        staticQueryData: _objectSpread({}, getStaticQueryResults())\n      });\n    };\n\n    _this2.state = {\n      staticQueryData: _objectSpread({}, getStaticQueryResults())\n    };\n    return _this2;\n  }\n\n  _createClass(StaticQueryStore, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      ___emitter.on(\"staticQueryResult\", this.handleMittEvent);\n\n      ___emitter.on(\"onPostLoadPageResources\", this.handleMittEvent);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      ___emitter.off(\"staticQueryResult\", this.handleMittEvent);\n\n      ___emitter.off(\"onPostLoadPageResources\", this.handleMittEvent);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      return this.state.staticQueryData !== nextState.staticQueryData;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(StaticQueryContext.Provider, {\n        value: this.state.staticQueryData,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 7\n        }\n      }, this.props.children);\n    }\n  }]);\n\n  return StaticQueryStore;\n}(React.Component);","map":{"version":3,"sources":["/Users/aliristang/Desktop/prize-website/.cache/query-result-store.js"],"names":["React","StaticQueryContext","registerPath","socketRegisterPath","unregisterPath","socketUnregisterPath","PageRenderer","normalizePagePath","loader","getStaticQueryResults","process","env","NODE_ENV","Error","getPathFromProps","props","pageResources","page","path","undefined","PageQueryStore","handleMittEvent","setState","state","loadPageSync","pageData","___emitter","on","off","nextProps","nextState","location","json","newPath","Component","StaticQueryStore","staticQueryData","children"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport { StaticQueryContext } from \"gatsby\"\nimport {\n  registerPath as socketRegisterPath,\n  unregisterPath as socketUnregisterPath,\n} from \"./socketIo\"\nimport PageRenderer from \"./page-renderer\"\nimport normalizePagePath from \"./normalize-page-path\"\nimport loader, { getStaticQueryResults } from \"./loader\"\n\nif (process.env.NODE_ENV === `production`) {\n  throw new Error(\n    `It appears like Gatsby is misconfigured. JSONStore is Gatsby internal ` +\n      `development-only component and should never be used in production.\\n\\n` +\n      `Unless your site has a complex or custom webpack/Gatsby ` +\n      `configuration this is likely a bug in Gatsby. ` +\n      `Please report this at https://github.com/gatsbyjs/gatsby/issues ` +\n      `with steps to reproduce this error.`\n  )\n}\n\nconst getPathFromProps = props =>\n  props.pageResources && props.pageResources.page\n    ? normalizePagePath(props.pageResources.page.path)\n    : undefined\n\nexport class PageQueryStore extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      pageData: null,\n      path: null,\n    }\n  }\n\n  handleMittEvent = () => {\n    this.setState(state => {\n      return {\n        page: state.path\n          ? loader.loadPageSync(normalizePagePath(state.path))\n          : null,\n      }\n    })\n  }\n\n  componentDidMount() {\n    socketRegisterPath(getPathFromProps(this.props))\n    ___emitter.on(`pageQueryResult`, this.handleMittEvent)\n    ___emitter.on(`onPostLoadPageResources`, this.handleMittEvent)\n  }\n\n  componentWillUnmount() {\n    socketUnregisterPath(this.state.path)\n    ___emitter.off(`pageQueryResult`, this.handleMittEvent)\n    ___emitter.off(`onPostLoadPageResources`, this.handleMittEvent)\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    const newPath = getPathFromProps(props)\n    if (newPath !== state.path) {\n      socketUnregisterPath(state.path)\n      socketRegisterPath(newPath)\n      return {\n        path: newPath,\n        page: newPath ? loader.loadPageSync(normalizePagePath(newPath)) : null,\n      }\n    }\n\n    return null\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // We want to update this component when:\n    // - location changed\n    // - page data for path changed\n\n    return (\n      this.props.location !== nextProps.location ||\n      this.state.path !== nextState.path ||\n      this.state.page !== nextState.page\n    )\n  }\n\n  render() {\n    // eslint-disable-next-line\n    if (!this.state.page) {\n      return <div />\n    }\n\n    return <PageRenderer {...this.props} {...this.state.page.json} />\n  }\n}\n\nexport class StaticQueryStore extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      staticQueryData: { ...getStaticQueryResults() },\n    }\n  }\n\n  handleMittEvent = () => {\n    this.setState({\n      staticQueryData: { ...getStaticQueryResults() },\n    })\n  }\n\n  componentDidMount() {\n    ___emitter.on(`staticQueryResult`, this.handleMittEvent)\n    ___emitter.on(`onPostLoadPageResources`, this.handleMittEvent)\n  }\n\n  componentWillUnmount() {\n    ___emitter.off(`staticQueryResult`, this.handleMittEvent)\n    ___emitter.off(`onPostLoadPageResources`, this.handleMittEvent)\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // We want to update this component when:\n    // - static query results changed\n\n    return this.state.staticQueryData !== nextState.staticQueryData\n  }\n\n  render() {\n    return (\n      <StaticQueryContext.Provider value={this.state.staticQueryData}>\n        {this.props.children}\n      </StaticQueryContext.Provider>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}